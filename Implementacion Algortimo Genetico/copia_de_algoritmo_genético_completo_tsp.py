# -*- coding: utf-8 -*-
"""Copia de Algoritmo genÃ©tico completo TSP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NOOWTdOiK5Fr9lE4yr9bzWGgsHhzdhVW

# Introduction
Genetic algorithms work by iterating over generations of populations and evaluation how well these populations solve a problem. At the end of a generation, the best individuals are selected to produce the next generation. 

The code presented in this blog has been adapted from:


**Zaccone G. (2019). Natural Computing with Python: Learn to implement genetic and evolutionary algorithms for problem solving in a pythonic way. BPB Publications.**

# Imports
First we import all necessary modules.
"""

import numpy as np, random, operator, pandas as pd, matplotlib.pyplot as plt

"""# Data Representation
Because we are going to work with the simplest form of the TSP, we need a way to represent the data:
"""

#Create class to handle "cities"

class Street:
    def __init__(self,name, x, y):
        self.name = name
        self.x = x
        self.y = y
        self.w_vehicles=0
    
    def distance(self, Street):

        xDis = abs(self.x - Street.x)
        yDis = abs(self.y - Street.y)
        distance = np.sqrt((xDis ** 2) + (yDis ** 2))
        return distance
    
    def __repr__(self):
        return "(" + str(self.name)+ ")"

"""# How the algorithm works?

## The concept of individual
An individual can be seen as a single instance of the problem, for this case it's easy to see that the individual is the sequence of "cities" and the order that they are visited.

## 


Genetic algorithms mimic natural structures using the idea of "Survival of the fittest", so it's important to define a common fitness function for all individuals. For this case, the fitness of an individual is the sum of the distance for each pair of consecutive cities, including the sum of the last Street in the sequence and the first (because TSP forms a loop).
>$Fitness=[\sum_{i=1}^{N-1} Distance(Street_{i},Street_{i+1})]+Distance(Street_{N},Street_{1})$

This "Distance" function is just the euclidian distance between each Street.
"""

#Create a fitness function

class Fitness:
    def __init__(self, route):
        self.route = route
        self.distance = 0
        self.fitness= 0.0
    
    def routeDistance(self):

        if self.distance ==0:
            pathDistance = 0
            for i in range(0, len(self.route)):
                if(self.route[i].name=="SMP"): 
                    break
                fromStreet = self.route[i]
                toStreet = None
                if i + 1 < len(self.route):
                    toStreet = self.route[i + 1]
                else:
                    toStreet = self.route[0]
                pathDistance += fromStreet.distance(toStreet)
            print("LLEGO A SU DESTINO FINAL")    
            self.distance = pathDistance

            if(self.distance==0):
                return 1
        return self.distance
    
    def routeFitness(self):
        if self.fitness == 0:
            self.fitness = 1 / float(self.routeDistance())
        return self.fitness

"""## Mutation and Breeding
The algorithm creates the next generations using two methods, either mutating single individuals based on a probability, or "mating" two individual to create a new one. Here we define all necesarry functions to perform the algorithm.
"""

#Create our initial population
#Route generator
#This method randomizes the order of the cities, this mean that this method creates a random individual.
def createRoute(StreetList):
    route = random.sample(StreetList, len(StreetList))
    return route


#Create first "population" (list of routes)
#This method created a random population of the specified size.

def initialPopulation(popSize, StreetList):#,start,end)
    population = []

    for i in range(0, popSize):
       
        route =createRoute(StreetList)

        population.append(route)
        print("ruta")
        print(createRoute(StreetList))
    return population


#Create the genetic algorithm
#Rank individuals
#This function takes a population and orders it in descending order using the fitness of each individual
def rankRoutes(population):
    fitnessResults = {}
    for i in range(0,len(population)):
        fitnessResults[i] = Fitness(population[i]).routeFitness()
    sorted_results=sorted(fitnessResults.items(), key = operator.itemgetter(1), reverse = True)
    return sorted_results



#Create a selection function that will be used to make the list of parent routes

def selection(popRanked, eliteSize):
    selectionResults = []
    df = pd.DataFrame(np.array(popRanked), columns=["Index","Fitness"])
    df['cum_sum'] = df.Fitness.cumsum()
    df['cum_perc'] = 100*df.cum_sum/df.Fitness.sum()
    
    for i in range(0, eliteSize):
        selectionResults.append(popRanked[i][0])
    for i in range(0, len(popRanked) - eliteSize):
        pick = 100*random.random()
        for i in range(0, len(popRanked)):
            if pick <= df.iat[i,3]:
                selectionResults.append(popRanked[i][0])
                break
    return selectionResults



#Create mating pool

def matingPool(population, selectionResults):
    matingpool = []
    for i in range(0, len(selectionResults)):
        index = selectionResults[i]
        matingpool.append(population[index])
    return matingpool




#Create a crossover function for two parents to create one child
def breed(parent1, parent2):
    child = []
    childP1 = []
    childP2 = []
    
    geneA = int(random.random() * len(parent1))
    geneB = int(random.random() * len(parent1))
    
    startGene = min(geneA, geneB)
    endGene = max(geneA, geneB)

    for i in range(startGene, endGene):
        childP1.append(parent1[i])
        

    childP2 = [item for item in parent2 if item not in childP1]
    print(startGene, endGene)

    print(parent1)
    print(parent2)

    print(childP1)
    print(childP2)
    child = childP1 + childP2

    print(child)
    return child

#Create function to run crossover over full mating pool

def breedPopulation(matingpool, eliteSize):
    children = []
    length = len(matingpool) - eliteSize
    pool = random.sample(matingpool, len(matingpool))

    for i in range(0,eliteSize):
        children.append(matingpool[i])
    
    for i in range(0, length):
        child = breed(pool[i], pool[len(matingpool)-i-1])
        children.append(child)
    return children




#Create function to mutate a single route
def mutate(individual, mutationRate):
    for swapped in range(len(individual)):
        if(random.random() < mutationRate):
            swapWith = int(random.random() * len(individual))
            
            Street1 = individual[swapped]
            Street2 = individual[swapWith]
            
            individual[swapped] = Street2
            individual[swapWith] = Street1
    return individual



#Create function to run mutation over entire population

def mutatePopulation(population, mutationRate):
    mutatedPop = []
    
    for ind in range(0, len(population)):
        mutatedInd = mutate(population[ind], mutationRate)
        mutatedPop.append(mutatedInd)
    return mutatedPop



#Put all steps together to create the next generation

def nextGeneration(currentGen, eliteSize, mutationRate):
    popRanked = rankRoutes(currentGen)
    selectionResults = selection(popRanked, eliteSize)
    matingpool = matingPool(currentGen, selectionResults)
    children = breedPopulation(matingpool, eliteSize)
    nextGeneration = mutatePopulation(children, mutationRate)
    return nextGeneration

"""## The genetic algorithm
With all these function defined, all that is left is to write the definition of the genetic algorithm.
"""

#Final step: create the genetic algorithm

def geneticAlgorithm(population, popSize, eliteSize, mutationRate, generations):#,start,end)
    pop = initialPopulation(popSize, population)#,start,end)
    progress = [1 / rankRoutes(pop)[0][1]]
    print("Initial distance: " + str(progress[0]))
    
    for i in range(1, generations+1):
        
        pop = nextGeneration(pop, eliteSize, mutationRate)
        progress.append(1 / rankRoutes(pop)[0][1])
        if i%50==0:
          print('Generation '+str(i),"Distance: ",progress[i])
        
        
    bestRouteIndex = rankRoutes(pop)[0][0]
    bestRoute = pop[bestRouteIndex]
    
    plt.plot(progress)
    plt.ylabel('Distance')
    plt.xlabel('Generation')
    plt.title('Best Fitness vs Generation')
    plt.tight_layout()
    plt.show()

    
    
    return bestRoute

"""## Testing
Know we create a list of cities and run the algorithm, this should return the best route found in the last generation.
"""

#Running the genetic algorithm
#Create list of cities
StreetList = []
StreetList1 = ["CHORRILLOS","SURCO","SAN BORJA","SJL","SJM","AGUSTINO","MIRAFLORES","BARRANCO","LA MOLINA","SMP"]


for i in range(0,10):
    StreetList.append(Street(name = StreetList1[i], x=int(random.random() * 200), y=int(random.random() * 200)))


best_route=geneticAlgorithm(population=StreetList, popSize=30, eliteSize=20, mutationRate=0.01, generations=1)#,"CHORRILLOS","SMP")
x=[]
y=[]
for i in best_route:
  x.append(i.x)
  y.append(i.y)
x.append(best_route[0].x)
y.append(best_route[0].y)
plt.plot(x, y, '--o')
plt.xlabel('X')
plt.ylabel('Y')
ax=plt.gca()
plt.title('Final Route Layout')
bbox_props = dict(boxstyle="circle,pad=0.3", fc='C0', ec="black", lw=0.5)
for i in range(1,len(StreetList)+1):
  ax.text(StreetList[i-1].x, StreetList[i-1].y, StreetList1[i-1], ha="center", va="center",
            size=5,
            bbox=bbox_props)
plt.tight_layout()
plt.show()